/*
 * App Store Connect API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.adguard.stores.appstoreconnect.api;

import com.adguard.stores.appstoreconnect.ApiClient;
import com.adguard.stores.appstoreconnect.ApiException;
import com.adguard.stores.appstoreconnect.ApiResponse;
import com.adguard.stores.appstoreconnect.Configuration;
import com.adguard.stores.appstoreconnect.Pair;

import com.adguard.stores.appstoreconnect.model.BuildsResponse;
import com.adguard.stores.appstoreconnect.model.CiBuildActionsResponse;
import com.adguard.stores.appstoreconnect.model.CiBuildRunActionsLinkagesResponse;
import com.adguard.stores.appstoreconnect.model.CiBuildRunBuildsLinkagesResponse;
import com.adguard.stores.appstoreconnect.model.CiBuildRunCreateRequest;
import com.adguard.stores.appstoreconnect.model.CiBuildRunResponse;
import com.adguard.stores.appstoreconnect.model.ErrorResponse;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Locale;
import java.util.function.Consumer;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
public class CiBuildRunsApi {
  /**
   * Utility class for extending HttpRequest.Builder functionality.
   */
  private static class HttpRequestBuilderExtensions {
    /**
     * Adds additional headers to the provided HttpRequest.Builder. Useful for adding method/endpoint specific headers.
     *
     * @param builder the HttpRequest.Builder to which headers will be added
     * @param headers a map of header names and values to add; may be null
     * @return the same HttpRequest.Builder instance with the additional headers set
     */
    static HttpRequest.Builder withAdditionalHeaders(HttpRequest.Builder builder, Map<String, String> headers) {
        if (headers != null) {
            for (Map.Entry<String, String> entry : headers.entrySet()) {
                builder.header(entry.getKey(), entry.getValue());
            }
        }
        return builder;
    }
  }
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public CiBuildRunsApi() {
    this(Configuration.getDefaultApiClient());
  }

  public CiBuildRunsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }


  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Download file from the given response.
   *
   * @param response Response
   * @return File
   * @throws ApiException If fail to read file content from response and write to disk
   */
  public File downloadFileFromResponse(HttpResponse<InputStream> response) throws ApiException {
    try {
      File file = prepareDownloadFile(response);
      java.nio.file.Files.copy(response.body(), file.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
      return file;
    } catch (IOException e) {
      throw new ApiException(e);
    }
  }

  /**
   * <p>Prepare the file for download from the response.</p>
   *
   * @param response a {@link java.net.http.HttpResponse} object.
   * @return a {@link java.io.File} object.
   * @throws java.io.IOException if any.
   */
  private File prepareDownloadFile(HttpResponse<InputStream> response) throws IOException {
    String filename = null;
    java.util.Optional<String> contentDisposition = response.headers().firstValue("Content-Disposition");
    if (contentDisposition.isPresent() && !"".equals(contentDisposition.get())) {
      // Get filename from the Content-Disposition header.
      java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("filename=['\"]?([^'\"\\s]+)['\"]?");
      java.util.regex.Matcher matcher = pattern.matcher(contentDisposition.get());
      if (matcher.find())
        filename = matcher.group(1);
    }
    File file = null;
    if (filename != null) {
      java.nio.file.Path tempDir = java.nio.file.Files.createTempDirectory("swagger-gen-native");
      java.nio.file.Path filePath = java.nio.file.Files.createFile(tempDir.resolve(filename));
      file = filePath.toFile();
      tempDir.toFile().deleteOnExit();   // best effort cleanup
      file.deleteOnExit(); // best effort cleanup
    } else {
      file = java.nio.file.Files.createTempFile("download-", "").toFile();
      file.deleteOnExit(); // best effort cleanup
    }
    return file;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions (optional)
   * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @return CiBuildActionsResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildActionsResponse ciBuildRunsActionsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildActions, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include) throws ApiException {
    return ciBuildRunsActionsGetToManyRelated(id, fieldsCiBuildActions, fieldsCiBuildRuns, limit, include, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions (optional)
   * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param headers Optional headers to include in the request
   * @return CiBuildActionsResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildActionsResponse ciBuildRunsActionsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildActions, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, Map<String, String> headers) throws ApiException {
    ApiResponse<CiBuildActionsResponse> localVarResponse = ciBuildRunsActionsGetToManyRelatedWithHttpInfo(id, fieldsCiBuildActions, fieldsCiBuildRuns, limit, include, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions (optional)
   * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @return ApiResponse&lt;CiBuildActionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildActionsResponse> ciBuildRunsActionsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildActions, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include) throws ApiException {
    return ciBuildRunsActionsGetToManyRelatedWithHttpInfo(id, fieldsCiBuildActions, fieldsCiBuildRuns, limit, include, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsCiBuildActions the fields to include for returned resources of type ciBuildActions (optional)
   * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;CiBuildActionsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildActionsResponse> ciBuildRunsActionsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildActions, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = ciBuildRunsActionsGetToManyRelatedRequestBuilder(id, fieldsCiBuildActions, fieldsCiBuildRuns, limit, include, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("ciBuildRunsActionsGetToManyRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<CiBuildActionsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        CiBuildActionsResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<CiBuildActionsResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<CiBuildActionsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder ciBuildRunsActionsGetToManyRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildActions, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling ciBuildRunsActionsGetToManyRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/ciBuildRuns/{id}/actions"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[ciBuildActions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[ciBuildActions]", fieldsCiBuildActions));
    localVarQueryParameterBaseName = "fields[ciBuildRuns]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[ciBuildRuns]", fieldsCiBuildRuns));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParameterBaseName = "include";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "include", include));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return CiBuildRunActionsLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildRunActionsLinkagesResponse ciBuildRunsActionsGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return ciBuildRunsActionsGetToManyRelationship(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return CiBuildRunActionsLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildRunActionsLinkagesResponse ciBuildRunsActionsGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<CiBuildRunActionsLinkagesResponse> localVarResponse = ciBuildRunsActionsGetToManyRelationshipWithHttpInfo(id, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;CiBuildRunActionsLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildRunActionsLinkagesResponse> ciBuildRunsActionsGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return ciBuildRunsActionsGetToManyRelationshipWithHttpInfo(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;CiBuildRunActionsLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildRunActionsLinkagesResponse> ciBuildRunsActionsGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = ciBuildRunsActionsGetToManyRelationshipRequestBuilder(id, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("ciBuildRunsActionsGetToManyRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<CiBuildRunActionsLinkagesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        CiBuildRunActionsLinkagesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<CiBuildRunActionsLinkagesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<CiBuildRunActionsLinkagesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder ciBuildRunsActionsGetToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling ciBuildRunsActionsGetToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/ciBuildRuns/{id}/relationships/actions"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterVersion filter by attribute &#39;version&#39; (optional)
   * @param filterExpired filter by attribute &#39;expired&#39; (optional)
   * @param filterProcessingState filter by attribute &#39;processingState&#39; (optional)
   * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute &#39;betaAppReviewSubmission.betaReviewState&#39; (optional)
   * @param filterUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param filterPreReleaseVersionVersion filter by attribute &#39;preReleaseVersion.version&#39; (optional)
   * @param filterPreReleaseVersionPlatform filter by attribute &#39;preReleaseVersion.platform&#39; (optional)
   * @param filterBuildAudienceType filter by attribute &#39;buildAudienceType&#39; (optional)
   * @param filterPreReleaseVersion filter by id(s) of related &#39;preReleaseVersion&#39; (optional)
   * @param filterApp filter by id(s) of related &#39;app&#39; (optional)
   * @param filterBetaGroups filter by id(s) of related &#39;betaGroups&#39; (optional)
   * @param filterAppStoreVersion filter by id(s) of related &#39;appStoreVersion&#39; (optional)
   * @param filterId filter by id(s) (optional)
   * @param existsUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param sort comma-separated list of sort expressions; resources will be sorted as specified (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param fieldsBuildBundles the fields to include for returned resources of type buildBundles (optional)
   * @param fieldsBuildUploads the fields to include for returned resources of type buildUploads (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @return BuildsResponse
   * @throws ApiException if fails to make API call
   */
  public BuildsResponse ciBuildRunsBuildsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaGroups, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> fieldsBuildBundles, @jakarta.annotation.Nullable List<String> fieldsBuildUploads, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitIndividualTesters, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitBuildBundles) throws ApiException {
    return ciBuildRunsBuildsGetToManyRelated(id, filterVersion, filterExpired, filterProcessingState, filterBetaAppReviewSubmissionBetaReviewState, filterUsesNonExemptEncryption, filterPreReleaseVersionVersion, filterPreReleaseVersionPlatform, filterBuildAudienceType, filterPreReleaseVersion, filterApp, filterBetaGroups, filterAppStoreVersion, filterId, existsUsesNonExemptEncryption, sort, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaGroups, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, fieldsBuildBundles, fieldsBuildUploads, limit, include, limitIndividualTesters, limitBetaGroups, limitBetaBuildLocalizations, limitIcons, limitBuildBundles, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterVersion filter by attribute &#39;version&#39; (optional)
   * @param filterExpired filter by attribute &#39;expired&#39; (optional)
   * @param filterProcessingState filter by attribute &#39;processingState&#39; (optional)
   * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute &#39;betaAppReviewSubmission.betaReviewState&#39; (optional)
   * @param filterUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param filterPreReleaseVersionVersion filter by attribute &#39;preReleaseVersion.version&#39; (optional)
   * @param filterPreReleaseVersionPlatform filter by attribute &#39;preReleaseVersion.platform&#39; (optional)
   * @param filterBuildAudienceType filter by attribute &#39;buildAudienceType&#39; (optional)
   * @param filterPreReleaseVersion filter by id(s) of related &#39;preReleaseVersion&#39; (optional)
   * @param filterApp filter by id(s) of related &#39;app&#39; (optional)
   * @param filterBetaGroups filter by id(s) of related &#39;betaGroups&#39; (optional)
   * @param filterAppStoreVersion filter by id(s) of related &#39;appStoreVersion&#39; (optional)
   * @param filterId filter by id(s) (optional)
   * @param existsUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param sort comma-separated list of sort expressions; resources will be sorted as specified (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param fieldsBuildBundles the fields to include for returned resources of type buildBundles (optional)
   * @param fieldsBuildUploads the fields to include for returned resources of type buildUploads (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return BuildsResponse
   * @throws ApiException if fails to make API call
   */
  public BuildsResponse ciBuildRunsBuildsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaGroups, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> fieldsBuildBundles, @jakarta.annotation.Nullable List<String> fieldsBuildUploads, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitIndividualTesters, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitBuildBundles, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildsResponse> localVarResponse = ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(id, filterVersion, filterExpired, filterProcessingState, filterBetaAppReviewSubmissionBetaReviewState, filterUsesNonExemptEncryption, filterPreReleaseVersionVersion, filterPreReleaseVersionPlatform, filterBuildAudienceType, filterPreReleaseVersion, filterApp, filterBetaGroups, filterAppStoreVersion, filterId, existsUsesNonExemptEncryption, sort, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaGroups, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, fieldsBuildBundles, fieldsBuildUploads, limit, include, limitIndividualTesters, limitBetaGroups, limitBetaBuildLocalizations, limitIcons, limitBuildBundles, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterVersion filter by attribute &#39;version&#39; (optional)
   * @param filterExpired filter by attribute &#39;expired&#39; (optional)
   * @param filterProcessingState filter by attribute &#39;processingState&#39; (optional)
   * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute &#39;betaAppReviewSubmission.betaReviewState&#39; (optional)
   * @param filterUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param filterPreReleaseVersionVersion filter by attribute &#39;preReleaseVersion.version&#39; (optional)
   * @param filterPreReleaseVersionPlatform filter by attribute &#39;preReleaseVersion.platform&#39; (optional)
   * @param filterBuildAudienceType filter by attribute &#39;buildAudienceType&#39; (optional)
   * @param filterPreReleaseVersion filter by id(s) of related &#39;preReleaseVersion&#39; (optional)
   * @param filterApp filter by id(s) of related &#39;app&#39; (optional)
   * @param filterBetaGroups filter by id(s) of related &#39;betaGroups&#39; (optional)
   * @param filterAppStoreVersion filter by id(s) of related &#39;appStoreVersion&#39; (optional)
   * @param filterId filter by id(s) (optional)
   * @param existsUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param sort comma-separated list of sort expressions; resources will be sorted as specified (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param fieldsBuildBundles the fields to include for returned resources of type buildBundles (optional)
   * @param fieldsBuildUploads the fields to include for returned resources of type buildUploads (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @return ApiResponse&lt;BuildsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildsResponse> ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaGroups, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> fieldsBuildBundles, @jakarta.annotation.Nullable List<String> fieldsBuildUploads, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitIndividualTesters, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitBuildBundles) throws ApiException {
    return ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(id, filterVersion, filterExpired, filterProcessingState, filterBetaAppReviewSubmissionBetaReviewState, filterUsesNonExemptEncryption, filterPreReleaseVersionVersion, filterPreReleaseVersionPlatform, filterBuildAudienceType, filterPreReleaseVersion, filterApp, filterBetaGroups, filterAppStoreVersion, filterId, existsUsesNonExemptEncryption, sort, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaGroups, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, fieldsBuildBundles, fieldsBuildUploads, limit, include, limitIndividualTesters, limitBetaGroups, limitBetaBuildLocalizations, limitIcons, limitBuildBundles, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterVersion filter by attribute &#39;version&#39; (optional)
   * @param filterExpired filter by attribute &#39;expired&#39; (optional)
   * @param filterProcessingState filter by attribute &#39;processingState&#39; (optional)
   * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute &#39;betaAppReviewSubmission.betaReviewState&#39; (optional)
   * @param filterUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param filterPreReleaseVersionVersion filter by attribute &#39;preReleaseVersion.version&#39; (optional)
   * @param filterPreReleaseVersionPlatform filter by attribute &#39;preReleaseVersion.platform&#39; (optional)
   * @param filterBuildAudienceType filter by attribute &#39;buildAudienceType&#39; (optional)
   * @param filterPreReleaseVersion filter by id(s) of related &#39;preReleaseVersion&#39; (optional)
   * @param filterApp filter by id(s) of related &#39;app&#39; (optional)
   * @param filterBetaGroups filter by id(s) of related &#39;betaGroups&#39; (optional)
   * @param filterAppStoreVersion filter by id(s) of related &#39;appStoreVersion&#39; (optional)
   * @param filterId filter by id(s) (optional)
   * @param existsUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param sort comma-separated list of sort expressions; resources will be sorted as specified (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaGroups the fields to include for returned resources of type betaGroups (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param fieldsBuildBundles the fields to include for returned resources of type buildBundles (optional)
   * @param fieldsBuildUploads the fields to include for returned resources of type buildUploads (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildsResponse> ciBuildRunsBuildsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaGroups, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> fieldsBuildBundles, @jakarta.annotation.Nullable List<String> fieldsBuildUploads, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitIndividualTesters, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitBuildBundles, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = ciBuildRunsBuildsGetToManyRelatedRequestBuilder(id, filterVersion, filterExpired, filterProcessingState, filterBetaAppReviewSubmissionBetaReviewState, filterUsesNonExemptEncryption, filterPreReleaseVersionVersion, filterPreReleaseVersionPlatform, filterBuildAudienceType, filterPreReleaseVersion, filterApp, filterBetaGroups, filterAppStoreVersion, filterId, existsUsesNonExemptEncryption, sort, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaGroups, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, fieldsBuildBundles, fieldsBuildUploads, limit, include, limitIndividualTesters, limitBetaGroups, limitBetaBuildLocalizations, limitIcons, limitBuildBundles, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("ciBuildRunsBuildsGetToManyRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildsResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildsResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder ciBuildRunsBuildsGetToManyRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaGroups, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> fieldsBuildBundles, @jakarta.annotation.Nullable List<String> fieldsBuildUploads, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitIndividualTesters, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitBuildBundles, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling ciBuildRunsBuildsGetToManyRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/ciBuildRuns/{id}/builds"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "filter[version]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[version]", filterVersion));
    localVarQueryParameterBaseName = "filter[expired]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[expired]", filterExpired));
    localVarQueryParameterBaseName = "filter[processingState]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[processingState]", filterProcessingState));
    localVarQueryParameterBaseName = "filter[betaAppReviewSubmission.betaReviewState]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[betaAppReviewSubmission.betaReviewState]", filterBetaAppReviewSubmissionBetaReviewState));
    localVarQueryParameterBaseName = "filter[usesNonExemptEncryption]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[usesNonExemptEncryption]", filterUsesNonExemptEncryption));
    localVarQueryParameterBaseName = "filter[preReleaseVersion.version]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[preReleaseVersion.version]", filterPreReleaseVersionVersion));
    localVarQueryParameterBaseName = "filter[preReleaseVersion.platform]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[preReleaseVersion.platform]", filterPreReleaseVersionPlatform));
    localVarQueryParameterBaseName = "filter[buildAudienceType]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[buildAudienceType]", filterBuildAudienceType));
    localVarQueryParameterBaseName = "filter[preReleaseVersion]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[preReleaseVersion]", filterPreReleaseVersion));
    localVarQueryParameterBaseName = "filter[app]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[app]", filterApp));
    localVarQueryParameterBaseName = "filter[betaGroups]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[betaGroups]", filterBetaGroups));
    localVarQueryParameterBaseName = "filter[appStoreVersion]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[appStoreVersion]", filterAppStoreVersion));
    localVarQueryParameterBaseName = "filter[id]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[id]", filterId));
    localVarQueryParameterBaseName = "exists[usesNonExemptEncryption]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("exists[usesNonExemptEncryption]", existsUsesNonExemptEncryption));
    localVarQueryParameterBaseName = "sort";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "sort", sort));
    localVarQueryParameterBaseName = "fields[builds]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[builds]", fieldsBuilds));
    localVarQueryParameterBaseName = "fields[preReleaseVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[preReleaseVersions]", fieldsPreReleaseVersions));
    localVarQueryParameterBaseName = "fields[betaTesters]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaTesters]", fieldsBetaTesters));
    localVarQueryParameterBaseName = "fields[betaGroups]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaGroups]", fieldsBetaGroups));
    localVarQueryParameterBaseName = "fields[betaBuildLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations));
    localVarQueryParameterBaseName = "fields[appEncryptionDeclarations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations));
    localVarQueryParameterBaseName = "fields[betaAppReviewSubmissions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions));
    localVarQueryParameterBaseName = "fields[apps]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[apps]", fieldsApps));
    localVarQueryParameterBaseName = "fields[buildBetaDetails]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildBetaDetails]", fieldsBuildBetaDetails));
    localVarQueryParameterBaseName = "fields[appStoreVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreVersions]", fieldsAppStoreVersions));
    localVarQueryParameterBaseName = "fields[buildIcons]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildIcons]", fieldsBuildIcons));
    localVarQueryParameterBaseName = "fields[buildBundles]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildBundles]", fieldsBuildBundles));
    localVarQueryParameterBaseName = "fields[buildUploads]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildUploads]", fieldsBuildUploads));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParameterBaseName = "include";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "include", include));
    localVarQueryParameterBaseName = "limit[individualTesters]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[individualTesters]", limitIndividualTesters));
    localVarQueryParameterBaseName = "limit[betaGroups]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[betaGroups]", limitBetaGroups));
    localVarQueryParameterBaseName = "limit[betaBuildLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[betaBuildLocalizations]", limitBetaBuildLocalizations));
    localVarQueryParameterBaseName = "limit[icons]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[icons]", limitIcons));
    localVarQueryParameterBaseName = "limit[buildBundles]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[buildBundles]", limitBuildBundles));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return CiBuildRunBuildsLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildRunBuildsLinkagesResponse ciBuildRunsBuildsGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return ciBuildRunsBuildsGetToManyRelationship(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return CiBuildRunBuildsLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildRunBuildsLinkagesResponse ciBuildRunsBuildsGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<CiBuildRunBuildsLinkagesResponse> localVarResponse = ciBuildRunsBuildsGetToManyRelationshipWithHttpInfo(id, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;CiBuildRunBuildsLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildRunBuildsLinkagesResponse> ciBuildRunsBuildsGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return ciBuildRunsBuildsGetToManyRelationshipWithHttpInfo(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;CiBuildRunBuildsLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildRunBuildsLinkagesResponse> ciBuildRunsBuildsGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = ciBuildRunsBuildsGetToManyRelationshipRequestBuilder(id, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("ciBuildRunsBuildsGetToManyRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<CiBuildRunBuildsLinkagesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        CiBuildRunBuildsLinkagesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<CiBuildRunBuildsLinkagesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<CiBuildRunBuildsLinkagesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder ciBuildRunsBuildsGetToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling ciBuildRunsBuildsGetToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/ciBuildRuns/{id}/relationships/builds"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param ciBuildRunCreateRequest CiBuildRun representation (required)
   * @return CiBuildRunResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildRunResponse ciBuildRunsCreateInstance(@jakarta.annotation.Nonnull CiBuildRunCreateRequest ciBuildRunCreateRequest) throws ApiException {
    return ciBuildRunsCreateInstance(ciBuildRunCreateRequest, null);
  }

  /**
   * 
   * 
   * @param ciBuildRunCreateRequest CiBuildRun representation (required)
   * @param headers Optional headers to include in the request
   * @return CiBuildRunResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildRunResponse ciBuildRunsCreateInstance(@jakarta.annotation.Nonnull CiBuildRunCreateRequest ciBuildRunCreateRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<CiBuildRunResponse> localVarResponse = ciBuildRunsCreateInstanceWithHttpInfo(ciBuildRunCreateRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param ciBuildRunCreateRequest CiBuildRun representation (required)
   * @return ApiResponse&lt;CiBuildRunResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildRunResponse> ciBuildRunsCreateInstanceWithHttpInfo(@jakarta.annotation.Nonnull CiBuildRunCreateRequest ciBuildRunCreateRequest) throws ApiException {
    return ciBuildRunsCreateInstanceWithHttpInfo(ciBuildRunCreateRequest, null);
  }

  /**
   * 
   * 
   * @param ciBuildRunCreateRequest CiBuildRun representation (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;CiBuildRunResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildRunResponse> ciBuildRunsCreateInstanceWithHttpInfo(@jakarta.annotation.Nonnull CiBuildRunCreateRequest ciBuildRunCreateRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = ciBuildRunsCreateInstanceRequestBuilder(ciBuildRunCreateRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("ciBuildRunsCreateInstance", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<CiBuildRunResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        CiBuildRunResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<CiBuildRunResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<CiBuildRunResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder ciBuildRunsCreateInstanceRequestBuilder(@jakarta.annotation.Nonnull CiBuildRunCreateRequest ciBuildRunCreateRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'ciBuildRunCreateRequest' is set
    if (ciBuildRunCreateRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'ciBuildRunCreateRequest' when calling ciBuildRunsCreateInstance");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/ciBuildRuns";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(ciBuildRunCreateRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBuilds maximum number of related builds returned (when they are included) (optional)
   * @return CiBuildRunResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildRunResponse ciBuildRunsGetInstance(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBuilds) throws ApiException {
    return ciBuildRunsGetInstance(id, fieldsCiBuildRuns, fieldsBuilds, include, limitBuilds, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBuilds maximum number of related builds returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return CiBuildRunResponse
   * @throws ApiException if fails to make API call
   */
  public CiBuildRunResponse ciBuildRunsGetInstance(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBuilds, Map<String, String> headers) throws ApiException {
    ApiResponse<CiBuildRunResponse> localVarResponse = ciBuildRunsGetInstanceWithHttpInfo(id, fieldsCiBuildRuns, fieldsBuilds, include, limitBuilds, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBuilds maximum number of related builds returned (when they are included) (optional)
   * @return ApiResponse&lt;CiBuildRunResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildRunResponse> ciBuildRunsGetInstanceWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBuilds) throws ApiException {
    return ciBuildRunsGetInstanceWithHttpInfo(id, fieldsCiBuildRuns, fieldsBuilds, include, limitBuilds, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsCiBuildRuns the fields to include for returned resources of type ciBuildRuns (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBuilds maximum number of related builds returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;CiBuildRunResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CiBuildRunResponse> ciBuildRunsGetInstanceWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBuilds, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = ciBuildRunsGetInstanceRequestBuilder(id, fieldsCiBuildRuns, fieldsBuilds, include, limitBuilds, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("ciBuildRunsGetInstance", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<CiBuildRunResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        CiBuildRunResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<CiBuildRunResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<CiBuildRunResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder ciBuildRunsGetInstanceRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsCiBuildRuns, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBuilds, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling ciBuildRunsGetInstance");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/ciBuildRuns/{id}"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[ciBuildRuns]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[ciBuildRuns]", fieldsCiBuildRuns));
    localVarQueryParameterBaseName = "fields[builds]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[builds]", fieldsBuilds));
    localVarQueryParameterBaseName = "include";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "include", include));
    localVarQueryParameterBaseName = "limit[builds]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[builds]", limitBuilds));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
