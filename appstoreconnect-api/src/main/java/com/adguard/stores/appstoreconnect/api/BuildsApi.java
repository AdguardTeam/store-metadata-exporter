/*
 * App Store Connect API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.adguard.stores.appstoreconnect.api;

import com.adguard.stores.appstoreconnect.ApiClient;
import com.adguard.stores.appstoreconnect.ApiException;
import com.adguard.stores.appstoreconnect.ApiResponse;
import com.adguard.stores.appstoreconnect.Configuration;
import com.adguard.stores.appstoreconnect.Pair;

import com.adguard.stores.appstoreconnect.model.AppEncryptionDeclarationWithoutIncludesResponse;
import com.adguard.stores.appstoreconnect.model.AppStoreVersionResponse;
import com.adguard.stores.appstoreconnect.model.AppWithoutIncludesResponse;
import com.adguard.stores.appstoreconnect.model.BetaAppReviewSubmissionWithoutIncludesResponse;
import com.adguard.stores.appstoreconnect.model.BetaBuildLocalizationsWithoutIncludesResponse;
import com.adguard.stores.appstoreconnect.model.BetaBuildUsagesV1MetricResponse;
import com.adguard.stores.appstoreconnect.model.BetaTestersWithoutIncludesResponse;
import com.adguard.stores.appstoreconnect.model.BuildAppEncryptionDeclarationLinkageRequest;
import com.adguard.stores.appstoreconnect.model.BuildAppEncryptionDeclarationLinkageResponse;
import com.adguard.stores.appstoreconnect.model.BuildAppLinkageResponse;
import com.adguard.stores.appstoreconnect.model.BuildAppStoreVersionLinkageResponse;
import com.adguard.stores.appstoreconnect.model.BuildBetaAppReviewSubmissionLinkageResponse;
import com.adguard.stores.appstoreconnect.model.BuildBetaBuildLocalizationsLinkagesResponse;
import com.adguard.stores.appstoreconnect.model.BuildBetaDetailResponse;
import com.adguard.stores.appstoreconnect.model.BuildBetaGroupsLinkagesRequest;
import com.adguard.stores.appstoreconnect.model.BuildBuildBetaDetailLinkageResponse;
import com.adguard.stores.appstoreconnect.model.BuildDiagnosticSignaturesLinkagesResponse;
import com.adguard.stores.appstoreconnect.model.BuildIconsLinkagesResponse;
import com.adguard.stores.appstoreconnect.model.BuildIconsWithoutIncludesResponse;
import com.adguard.stores.appstoreconnect.model.BuildIndividualTestersLinkagesRequest;
import com.adguard.stores.appstoreconnect.model.BuildIndividualTestersLinkagesResponse;
import com.adguard.stores.appstoreconnect.model.BuildPreReleaseVersionLinkageResponse;
import com.adguard.stores.appstoreconnect.model.BuildResponse;
import com.adguard.stores.appstoreconnect.model.BuildUpdateRequest;
import com.adguard.stores.appstoreconnect.model.BuildsResponse;
import com.adguard.stores.appstoreconnect.model.DiagnosticSignaturesResponse;
import com.adguard.stores.appstoreconnect.model.ErrorResponse;
import com.adguard.stores.appstoreconnect.model.PrereleaseVersionWithoutIncludesResponse;
import com.adguard.stores.appstoreconnect.model.XcodeMetrics;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Locale;
import java.util.function.Consumer;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
public class BuildsApi {
  /**
   * Utility class for extending HttpRequest.Builder functionality.
   */
  private static class HttpRequestBuilderExtensions {
    /**
     * Adds additional headers to the provided HttpRequest.Builder. Useful for adding method/endpoint specific headers.
     *
     * @param builder the HttpRequest.Builder to which headers will be added
     * @param headers a map of header names and values to add; may be null
     * @return the same HttpRequest.Builder instance with the additional headers set
     */
    static HttpRequest.Builder withAdditionalHeaders(HttpRequest.Builder builder, Map<String, String> headers) {
        if (headers != null) {
            for (Map.Entry<String, String> entry : headers.entrySet()) {
                builder.header(entry.getKey(), entry.getValue());
            }
        }
        return builder;
    }
  }
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public BuildsApi() {
    this(Configuration.getDefaultApiClient());
  }

  public BuildsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }


  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Download file from the given response.
   *
   * @param response Response
   * @return File
   * @throws ApiException If fail to read file content from response and write to disk
   */
  public File downloadFileFromResponse(HttpResponse<InputStream> response) throws ApiException {
    try {
      File file = prepareDownloadFile(response);
      java.nio.file.Files.copy(response.body(), file.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
      return file;
    } catch (IOException e) {
      throw new ApiException(e);
    }
  }

  /**
   * <p>Prepare the file for download from the response.</p>
   *
   * @param response a {@link java.net.http.HttpResponse} object.
   * @return a {@link java.io.File} object.
   * @throws java.io.IOException if any.
   */
  private File prepareDownloadFile(HttpResponse<InputStream> response) throws IOException {
    String filename = null;
    java.util.Optional<String> contentDisposition = response.headers().firstValue("Content-Disposition");
    if (contentDisposition.isPresent() && !"".equals(contentDisposition.get())) {
      // Get filename from the Content-Disposition header.
      java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("filename=['\"]?([^'\"\\s]+)['\"]?");
      java.util.regex.Matcher matcher = pattern.matcher(contentDisposition.get());
      if (matcher.find())
        filename = matcher.group(1);
    }
    File file = null;
    if (filename != null) {
      java.nio.file.Path tempDir = java.nio.file.Files.createTempDirectory("swagger-gen-native");
      java.nio.file.Path filePath = java.nio.file.Files.createFile(tempDir.resolve(filename));
      file = filePath.toFile();
      tempDir.toFile().deleteOnExit();   // best effort cleanup
      file.deleteOnExit(); // best effort cleanup
    } else {
      file = java.nio.file.Files.createTempFile("download-", "").toFile();
      file.deleteOnExit(); // best effort cleanup
    }
    return file;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @return AppEncryptionDeclarationWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public AppEncryptionDeclarationWithoutIncludesResponse buildsAppEncryptionDeclarationGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations) throws ApiException {
    return buildsAppEncryptionDeclarationGetToOneRelated(id, fieldsAppEncryptionDeclarations, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param headers Optional headers to include in the request
   * @return AppEncryptionDeclarationWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public AppEncryptionDeclarationWithoutIncludesResponse buildsAppEncryptionDeclarationGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, Map<String, String> headers) throws ApiException {
    ApiResponse<AppEncryptionDeclarationWithoutIncludesResponse> localVarResponse = buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(id, fieldsAppEncryptionDeclarations, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @return ApiResponse&lt;AppEncryptionDeclarationWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AppEncryptionDeclarationWithoutIncludesResponse> buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations) throws ApiException {
    return buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(id, fieldsAppEncryptionDeclarations, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;AppEncryptionDeclarationWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AppEncryptionDeclarationWithoutIncludesResponse> buildsAppEncryptionDeclarationGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsAppEncryptionDeclarationGetToOneRelatedRequestBuilder(id, fieldsAppEncryptionDeclarations, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsAppEncryptionDeclarationGetToOneRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<AppEncryptionDeclarationWithoutIncludesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        AppEncryptionDeclarationWithoutIncludesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<AppEncryptionDeclarationWithoutIncludesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<AppEncryptionDeclarationWithoutIncludesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsAppEncryptionDeclarationGetToOneRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsAppEncryptionDeclarationGetToOneRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/appEncryptionDeclaration"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[appEncryptionDeclarations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return BuildAppEncryptionDeclarationLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildAppEncryptionDeclarationLinkageResponse buildsAppEncryptionDeclarationGetToOneRelationship(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsAppEncryptionDeclarationGetToOneRelationship(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return BuildAppEncryptionDeclarationLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildAppEncryptionDeclarationLinkageResponse buildsAppEncryptionDeclarationGetToOneRelationship(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildAppEncryptionDeclarationLinkageResponse> localVarResponse = buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(id, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return ApiResponse&lt;BuildAppEncryptionDeclarationLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildAppEncryptionDeclarationLinkageResponse> buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildAppEncryptionDeclarationLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildAppEncryptionDeclarationLinkageResponse> buildsAppEncryptionDeclarationGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsAppEncryptionDeclarationGetToOneRelationshipRequestBuilder(id, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsAppEncryptionDeclarationGetToOneRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildAppEncryptionDeclarationLinkageResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildAppEncryptionDeclarationLinkageResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildAppEncryptionDeclarationLinkageResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildAppEncryptionDeclarationLinkageResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsAppEncryptionDeclarationGetToOneRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsAppEncryptionDeclarationGetToOneRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/appEncryptionDeclaration"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildAppEncryptionDeclarationLinkageRequest Related linkage (required)
   * @throws ApiException if fails to make API call
   */
  public void buildsAppEncryptionDeclarationUpdateToOneRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildAppEncryptionDeclarationLinkageRequest buildAppEncryptionDeclarationLinkageRequest) throws ApiException {
    buildsAppEncryptionDeclarationUpdateToOneRelationship(id, buildAppEncryptionDeclarationLinkageRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildAppEncryptionDeclarationLinkageRequest Related linkage (required)
   * @param headers Optional headers to include in the request
   * @throws ApiException if fails to make API call
   */
  public void buildsAppEncryptionDeclarationUpdateToOneRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildAppEncryptionDeclarationLinkageRequest buildAppEncryptionDeclarationLinkageRequest, Map<String, String> headers) throws ApiException {
    buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(id, buildAppEncryptionDeclarationLinkageRequest, headers);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildAppEncryptionDeclarationLinkageRequest Related linkage (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildAppEncryptionDeclarationLinkageRequest buildAppEncryptionDeclarationLinkageRequest) throws ApiException {
    return buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(id, buildAppEncryptionDeclarationLinkageRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildAppEncryptionDeclarationLinkageRequest Related linkage (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsAppEncryptionDeclarationUpdateToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildAppEncryptionDeclarationLinkageRequest buildAppEncryptionDeclarationLinkageRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsAppEncryptionDeclarationUpdateToOneRelationshipRequestBuilder(id, buildAppEncryptionDeclarationLinkageRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsAppEncryptionDeclarationUpdateToOneRelationship", localVarResponse);
        }
        return new ApiResponse<>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
          // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsAppEncryptionDeclarationUpdateToOneRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildAppEncryptionDeclarationLinkageRequest buildAppEncryptionDeclarationLinkageRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsAppEncryptionDeclarationUpdateToOneRelationship");
    }
    // verify the required parameter 'buildAppEncryptionDeclarationLinkageRequest' is set
    if (buildAppEncryptionDeclarationLinkageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'buildAppEncryptionDeclarationLinkageRequest' when calling buildsAppEncryptionDeclarationUpdateToOneRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/appEncryptionDeclaration"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(buildAppEncryptionDeclarationLinkageRequest);
      localVarRequestBuilder.method("PATCH", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @return AppWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public AppWithoutIncludesResponse buildsAppGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsApps) throws ApiException {
    return buildsAppGetToOneRelated(id, fieldsApps, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param headers Optional headers to include in the request
   * @return AppWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public AppWithoutIncludesResponse buildsAppGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsApps, Map<String, String> headers) throws ApiException {
    ApiResponse<AppWithoutIncludesResponse> localVarResponse = buildsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @return ApiResponse&lt;AppWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AppWithoutIncludesResponse> buildsAppGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsApps) throws ApiException {
    return buildsAppGetToOneRelatedWithHttpInfo(id, fieldsApps, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;AppWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AppWithoutIncludesResponse> buildsAppGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsApps, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsAppGetToOneRelatedRequestBuilder(id, fieldsApps, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsAppGetToOneRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<AppWithoutIncludesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        AppWithoutIncludesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<AppWithoutIncludesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<AppWithoutIncludesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsAppGetToOneRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsApps, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsAppGetToOneRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/app"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[apps]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[apps]", fieldsApps));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return BuildAppLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildAppLinkageResponse buildsAppGetToOneRelationship(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsAppGetToOneRelationship(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return BuildAppLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildAppLinkageResponse buildsAppGetToOneRelationship(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildAppLinkageResponse> localVarResponse = buildsAppGetToOneRelationshipWithHttpInfo(id, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return ApiResponse&lt;BuildAppLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildAppLinkageResponse> buildsAppGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsAppGetToOneRelationshipWithHttpInfo(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildAppLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildAppLinkageResponse> buildsAppGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsAppGetToOneRelationshipRequestBuilder(id, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsAppGetToOneRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildAppLinkageResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildAppLinkageResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildAppLinkageResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildAppLinkageResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsAppGetToOneRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsAppGetToOneRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/app"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations (optional)
   * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases (optional)
   * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions (optional)
   * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages (optional)
   * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails (optional)
   * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions (optional)
   * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences (optional)
   * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments (optional)
   * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included) (optional)
   * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included) (optional)
   * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included) (optional)
   * @return AppStoreVersionResponse
   * @throws ApiException if fails to make API call
   */
  public AppStoreVersionResponse buildsAppStoreVersionGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsAgeRatingDeclarations, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionLocalizations, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionPhasedReleases, @jakarta.annotation.Nullable List<String> fieldsGameCenterAppVersions, @jakarta.annotation.Nullable List<String> fieldsRoutingAppCoverages, @jakarta.annotation.Nullable List<String> fieldsAppStoreReviewDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionSubmissions, @jakarta.annotation.Nullable List<String> fieldsAppClipDefaultExperiences, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionExperiments, @jakarta.annotation.Nullable List<String> fieldsAlternativeDistributionPackages, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitAppStoreVersionLocalizations, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperiments, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperimentsV2) throws ApiException {
    return buildsAppStoreVersionGetToOneRelated(id, fieldsAppStoreVersions, fieldsApps, fieldsAgeRatingDeclarations, fieldsAppStoreVersionLocalizations, fieldsBuilds, fieldsAppStoreVersionPhasedReleases, fieldsGameCenterAppVersions, fieldsRoutingAppCoverages, fieldsAppStoreReviewDetails, fieldsAppStoreVersionSubmissions, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionExperiments, fieldsAlternativeDistributionPackages, include, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations (optional)
   * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases (optional)
   * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions (optional)
   * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages (optional)
   * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails (optional)
   * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions (optional)
   * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences (optional)
   * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments (optional)
   * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included) (optional)
   * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included) (optional)
   * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return AppStoreVersionResponse
   * @throws ApiException if fails to make API call
   */
  public AppStoreVersionResponse buildsAppStoreVersionGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsAgeRatingDeclarations, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionLocalizations, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionPhasedReleases, @jakarta.annotation.Nullable List<String> fieldsGameCenterAppVersions, @jakarta.annotation.Nullable List<String> fieldsRoutingAppCoverages, @jakarta.annotation.Nullable List<String> fieldsAppStoreReviewDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionSubmissions, @jakarta.annotation.Nullable List<String> fieldsAppClipDefaultExperiences, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionExperiments, @jakarta.annotation.Nullable List<String> fieldsAlternativeDistributionPackages, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitAppStoreVersionLocalizations, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperiments, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperimentsV2, Map<String, String> headers) throws ApiException {
    ApiResponse<AppStoreVersionResponse> localVarResponse = buildsAppStoreVersionGetToOneRelatedWithHttpInfo(id, fieldsAppStoreVersions, fieldsApps, fieldsAgeRatingDeclarations, fieldsAppStoreVersionLocalizations, fieldsBuilds, fieldsAppStoreVersionPhasedReleases, fieldsGameCenterAppVersions, fieldsRoutingAppCoverages, fieldsAppStoreReviewDetails, fieldsAppStoreVersionSubmissions, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionExperiments, fieldsAlternativeDistributionPackages, include, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations (optional)
   * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases (optional)
   * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions (optional)
   * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages (optional)
   * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails (optional)
   * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions (optional)
   * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences (optional)
   * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments (optional)
   * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included) (optional)
   * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included) (optional)
   * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included) (optional)
   * @return ApiResponse&lt;AppStoreVersionResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AppStoreVersionResponse> buildsAppStoreVersionGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsAgeRatingDeclarations, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionLocalizations, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionPhasedReleases, @jakarta.annotation.Nullable List<String> fieldsGameCenterAppVersions, @jakarta.annotation.Nullable List<String> fieldsRoutingAppCoverages, @jakarta.annotation.Nullable List<String> fieldsAppStoreReviewDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionSubmissions, @jakarta.annotation.Nullable List<String> fieldsAppClipDefaultExperiences, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionExperiments, @jakarta.annotation.Nullable List<String> fieldsAlternativeDistributionPackages, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitAppStoreVersionLocalizations, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperiments, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperimentsV2) throws ApiException {
    return buildsAppStoreVersionGetToOneRelatedWithHttpInfo(id, fieldsAppStoreVersions, fieldsApps, fieldsAgeRatingDeclarations, fieldsAppStoreVersionLocalizations, fieldsBuilds, fieldsAppStoreVersionPhasedReleases, fieldsGameCenterAppVersions, fieldsRoutingAppCoverages, fieldsAppStoreReviewDetails, fieldsAppStoreVersionSubmissions, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionExperiments, fieldsAlternativeDistributionPackages, include, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsAgeRatingDeclarations the fields to include for returned resources of type ageRatingDeclarations (optional)
   * @param fieldsAppStoreVersionLocalizations the fields to include for returned resources of type appStoreVersionLocalizations (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsAppStoreVersionPhasedReleases the fields to include for returned resources of type appStoreVersionPhasedReleases (optional)
   * @param fieldsGameCenterAppVersions the fields to include for returned resources of type gameCenterAppVersions (optional)
   * @param fieldsRoutingAppCoverages the fields to include for returned resources of type routingAppCoverages (optional)
   * @param fieldsAppStoreReviewDetails the fields to include for returned resources of type appStoreReviewDetails (optional)
   * @param fieldsAppStoreVersionSubmissions the fields to include for returned resources of type appStoreVersionSubmissions (optional)
   * @param fieldsAppClipDefaultExperiences the fields to include for returned resources of type appClipDefaultExperiences (optional)
   * @param fieldsAppStoreVersionExperiments the fields to include for returned resources of type appStoreVersionExperiments (optional)
   * @param fieldsAlternativeDistributionPackages the fields to include for returned resources of type alternativeDistributionPackages (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitAppStoreVersionLocalizations maximum number of related appStoreVersionLocalizations returned (when they are included) (optional)
   * @param limitAppStoreVersionExperiments maximum number of related appStoreVersionExperiments returned (when they are included) (optional)
   * @param limitAppStoreVersionExperimentsV2 maximum number of related appStoreVersionExperimentsV2 returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;AppStoreVersionResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AppStoreVersionResponse> buildsAppStoreVersionGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsAgeRatingDeclarations, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionLocalizations, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionPhasedReleases, @jakarta.annotation.Nullable List<String> fieldsGameCenterAppVersions, @jakarta.annotation.Nullable List<String> fieldsRoutingAppCoverages, @jakarta.annotation.Nullable List<String> fieldsAppStoreReviewDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionSubmissions, @jakarta.annotation.Nullable List<String> fieldsAppClipDefaultExperiences, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionExperiments, @jakarta.annotation.Nullable List<String> fieldsAlternativeDistributionPackages, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitAppStoreVersionLocalizations, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperiments, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperimentsV2, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsAppStoreVersionGetToOneRelatedRequestBuilder(id, fieldsAppStoreVersions, fieldsApps, fieldsAgeRatingDeclarations, fieldsAppStoreVersionLocalizations, fieldsBuilds, fieldsAppStoreVersionPhasedReleases, fieldsGameCenterAppVersions, fieldsRoutingAppCoverages, fieldsAppStoreReviewDetails, fieldsAppStoreVersionSubmissions, fieldsAppClipDefaultExperiences, fieldsAppStoreVersionExperiments, fieldsAlternativeDistributionPackages, include, limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments, limitAppStoreVersionExperimentsV2, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsAppStoreVersionGetToOneRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<AppStoreVersionResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        AppStoreVersionResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<AppStoreVersionResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<AppStoreVersionResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsAppStoreVersionGetToOneRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsAgeRatingDeclarations, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionLocalizations, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionPhasedReleases, @jakarta.annotation.Nullable List<String> fieldsGameCenterAppVersions, @jakarta.annotation.Nullable List<String> fieldsRoutingAppCoverages, @jakarta.annotation.Nullable List<String> fieldsAppStoreReviewDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionSubmissions, @jakarta.annotation.Nullable List<String> fieldsAppClipDefaultExperiences, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersionExperiments, @jakarta.annotation.Nullable List<String> fieldsAlternativeDistributionPackages, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitAppStoreVersionLocalizations, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperiments, @jakarta.annotation.Nullable Integer limitAppStoreVersionExperimentsV2, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsAppStoreVersionGetToOneRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/appStoreVersion"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[appStoreVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreVersions]", fieldsAppStoreVersions));
    localVarQueryParameterBaseName = "fields[apps]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[apps]", fieldsApps));
    localVarQueryParameterBaseName = "fields[ageRatingDeclarations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[ageRatingDeclarations]", fieldsAgeRatingDeclarations));
    localVarQueryParameterBaseName = "fields[appStoreVersionLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreVersionLocalizations]", fieldsAppStoreVersionLocalizations));
    localVarQueryParameterBaseName = "fields[builds]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[builds]", fieldsBuilds));
    localVarQueryParameterBaseName = "fields[appStoreVersionPhasedReleases]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreVersionPhasedReleases]", fieldsAppStoreVersionPhasedReleases));
    localVarQueryParameterBaseName = "fields[gameCenterAppVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[gameCenterAppVersions]", fieldsGameCenterAppVersions));
    localVarQueryParameterBaseName = "fields[routingAppCoverages]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[routingAppCoverages]", fieldsRoutingAppCoverages));
    localVarQueryParameterBaseName = "fields[appStoreReviewDetails]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreReviewDetails]", fieldsAppStoreReviewDetails));
    localVarQueryParameterBaseName = "fields[appStoreVersionSubmissions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreVersionSubmissions]", fieldsAppStoreVersionSubmissions));
    localVarQueryParameterBaseName = "fields[appClipDefaultExperiences]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appClipDefaultExperiences]", fieldsAppClipDefaultExperiences));
    localVarQueryParameterBaseName = "fields[appStoreVersionExperiments]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreVersionExperiments]", fieldsAppStoreVersionExperiments));
    localVarQueryParameterBaseName = "fields[alternativeDistributionPackages]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[alternativeDistributionPackages]", fieldsAlternativeDistributionPackages));
    localVarQueryParameterBaseName = "include";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "include", include));
    localVarQueryParameterBaseName = "limit[appStoreVersionLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[appStoreVersionLocalizations]", limitAppStoreVersionLocalizations));
    localVarQueryParameterBaseName = "limit[appStoreVersionExperiments]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[appStoreVersionExperiments]", limitAppStoreVersionExperiments));
    localVarQueryParameterBaseName = "limit[appStoreVersionExperimentsV2]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[appStoreVersionExperimentsV2]", limitAppStoreVersionExperimentsV2));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return BuildAppStoreVersionLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildAppStoreVersionLinkageResponse buildsAppStoreVersionGetToOneRelationship(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsAppStoreVersionGetToOneRelationship(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return BuildAppStoreVersionLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildAppStoreVersionLinkageResponse buildsAppStoreVersionGetToOneRelationship(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildAppStoreVersionLinkageResponse> localVarResponse = buildsAppStoreVersionGetToOneRelationshipWithHttpInfo(id, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return ApiResponse&lt;BuildAppStoreVersionLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildAppStoreVersionLinkageResponse> buildsAppStoreVersionGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsAppStoreVersionGetToOneRelationshipWithHttpInfo(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildAppStoreVersionLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildAppStoreVersionLinkageResponse> buildsAppStoreVersionGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsAppStoreVersionGetToOneRelationshipRequestBuilder(id, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsAppStoreVersionGetToOneRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildAppStoreVersionLinkageResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildAppStoreVersionLinkageResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildAppStoreVersionLinkageResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildAppStoreVersionLinkageResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsAppStoreVersionGetToOneRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsAppStoreVersionGetToOneRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/appStoreVersion"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @return BetaAppReviewSubmissionWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public BetaAppReviewSubmissionWithoutIncludesResponse buildsBetaAppReviewSubmissionGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions) throws ApiException {
    return buildsBetaAppReviewSubmissionGetToOneRelated(id, fieldsBetaAppReviewSubmissions, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param headers Optional headers to include in the request
   * @return BetaAppReviewSubmissionWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public BetaAppReviewSubmissionWithoutIncludesResponse buildsBetaAppReviewSubmissionGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, Map<String, String> headers) throws ApiException {
    ApiResponse<BetaAppReviewSubmissionWithoutIncludesResponse> localVarResponse = buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(id, fieldsBetaAppReviewSubmissions, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @return ApiResponse&lt;BetaAppReviewSubmissionWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BetaAppReviewSubmissionWithoutIncludesResponse> buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions) throws ApiException {
    return buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(id, fieldsBetaAppReviewSubmissions, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BetaAppReviewSubmissionWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BetaAppReviewSubmissionWithoutIncludesResponse> buildsBetaAppReviewSubmissionGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBetaAppReviewSubmissionGetToOneRelatedRequestBuilder(id, fieldsBetaAppReviewSubmissions, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBetaAppReviewSubmissionGetToOneRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BetaAppReviewSubmissionWithoutIncludesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BetaAppReviewSubmissionWithoutIncludesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BetaAppReviewSubmissionWithoutIncludesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BetaAppReviewSubmissionWithoutIncludesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBetaAppReviewSubmissionGetToOneRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBetaAppReviewSubmissionGetToOneRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/betaAppReviewSubmission"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[betaAppReviewSubmissions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return BuildBetaAppReviewSubmissionLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildBetaAppReviewSubmissionLinkageResponse buildsBetaAppReviewSubmissionGetToOneRelationship(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsBetaAppReviewSubmissionGetToOneRelationship(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return BuildBetaAppReviewSubmissionLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildBetaAppReviewSubmissionLinkageResponse buildsBetaAppReviewSubmissionGetToOneRelationship(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildBetaAppReviewSubmissionLinkageResponse> localVarResponse = buildsBetaAppReviewSubmissionGetToOneRelationshipWithHttpInfo(id, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return ApiResponse&lt;BuildBetaAppReviewSubmissionLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildBetaAppReviewSubmissionLinkageResponse> buildsBetaAppReviewSubmissionGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsBetaAppReviewSubmissionGetToOneRelationshipWithHttpInfo(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildBetaAppReviewSubmissionLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildBetaAppReviewSubmissionLinkageResponse> buildsBetaAppReviewSubmissionGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBetaAppReviewSubmissionGetToOneRelationshipRequestBuilder(id, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBetaAppReviewSubmissionGetToOneRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildBetaAppReviewSubmissionLinkageResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildBetaAppReviewSubmissionLinkageResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildBetaAppReviewSubmissionLinkageResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildBetaAppReviewSubmissionLinkageResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBetaAppReviewSubmissionGetToOneRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBetaAppReviewSubmissionGetToOneRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/betaAppReviewSubmission"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param limit maximum resources per page (optional)
   * @return BetaBuildLocalizationsWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public BetaBuildLocalizationsWithoutIncludesResponse buildsBetaBuildLocalizationsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsBetaBuildLocalizationsGetToManyRelated(id, fieldsBetaBuildLocalizations, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return BetaBuildLocalizationsWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public BetaBuildLocalizationsWithoutIncludesResponse buildsBetaBuildLocalizationsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<BetaBuildLocalizationsWithoutIncludesResponse> localVarResponse = buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsBetaBuildLocalizations, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;BetaBuildLocalizationsWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BetaBuildLocalizationsWithoutIncludesResponse> buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(id, fieldsBetaBuildLocalizations, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BetaBuildLocalizationsWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BetaBuildLocalizationsWithoutIncludesResponse> buildsBetaBuildLocalizationsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBetaBuildLocalizationsGetToManyRelatedRequestBuilder(id, fieldsBetaBuildLocalizations, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBetaBuildLocalizationsGetToManyRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BetaBuildLocalizationsWithoutIncludesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BetaBuildLocalizationsWithoutIncludesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BetaBuildLocalizationsWithoutIncludesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BetaBuildLocalizationsWithoutIncludesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBetaBuildLocalizationsGetToManyRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBetaBuildLocalizationsGetToManyRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/betaBuildLocalizations"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[betaBuildLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return BuildBetaBuildLocalizationsLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildBetaBuildLocalizationsLinkagesResponse buildsBetaBuildLocalizationsGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsBetaBuildLocalizationsGetToManyRelationship(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return BuildBetaBuildLocalizationsLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildBetaBuildLocalizationsLinkagesResponse buildsBetaBuildLocalizationsGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildBetaBuildLocalizationsLinkagesResponse> localVarResponse = buildsBetaBuildLocalizationsGetToManyRelationshipWithHttpInfo(id, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;BuildBetaBuildLocalizationsLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildBetaBuildLocalizationsLinkagesResponse> buildsBetaBuildLocalizationsGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsBetaBuildLocalizationsGetToManyRelationshipWithHttpInfo(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildBetaBuildLocalizationsLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildBetaBuildLocalizationsLinkagesResponse> buildsBetaBuildLocalizationsGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBetaBuildLocalizationsGetToManyRelationshipRequestBuilder(id, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBetaBuildLocalizationsGetToManyRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildBetaBuildLocalizationsLinkagesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildBetaBuildLocalizationsLinkagesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildBetaBuildLocalizationsLinkagesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildBetaBuildLocalizationsLinkagesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBetaBuildLocalizationsGetToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBetaBuildLocalizationsGetToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/betaBuildLocalizations"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum number of groups to return per page (optional)
   * @return BetaBuildUsagesV1MetricResponse
   * @throws ApiException if fails to make API call
   */
  public BetaBuildUsagesV1MetricResponse buildsBetaBuildUsagesGetMetrics(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsBetaBuildUsagesGetMetrics(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum number of groups to return per page (optional)
   * @param headers Optional headers to include in the request
   * @return BetaBuildUsagesV1MetricResponse
   * @throws ApiException if fails to make API call
   */
  public BetaBuildUsagesV1MetricResponse buildsBetaBuildUsagesGetMetrics(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<BetaBuildUsagesV1MetricResponse> localVarResponse = buildsBetaBuildUsagesGetMetricsWithHttpInfo(id, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum number of groups to return per page (optional)
   * @return ApiResponse&lt;BetaBuildUsagesV1MetricResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BetaBuildUsagesV1MetricResponse> buildsBetaBuildUsagesGetMetricsWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsBetaBuildUsagesGetMetricsWithHttpInfo(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum number of groups to return per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BetaBuildUsagesV1MetricResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BetaBuildUsagesV1MetricResponse> buildsBetaBuildUsagesGetMetricsWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBetaBuildUsagesGetMetricsRequestBuilder(id, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBetaBuildUsagesGetMetrics", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BetaBuildUsagesV1MetricResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BetaBuildUsagesV1MetricResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BetaBuildUsagesV1MetricResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BetaBuildUsagesV1MetricResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBetaBuildUsagesGetMetricsRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBetaBuildUsagesGetMetrics");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/metrics/betaBuildUsages"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildBetaGroupsLinkagesRequest List of related linkages (required)
   * @throws ApiException if fails to make API call
   */
  public void buildsBetaGroupsCreateToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest) throws ApiException {
    buildsBetaGroupsCreateToManyRelationship(id, buildBetaGroupsLinkagesRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildBetaGroupsLinkagesRequest List of related linkages (required)
   * @param headers Optional headers to include in the request
   * @throws ApiException if fails to make API call
   */
  public void buildsBetaGroupsCreateToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest, Map<String, String> headers) throws ApiException {
    buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(id, buildBetaGroupsLinkagesRequest, headers);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildBetaGroupsLinkagesRequest List of related linkages (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest) throws ApiException {
    return buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(id, buildBetaGroupsLinkagesRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildBetaGroupsLinkagesRequest List of related linkages (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsBetaGroupsCreateToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBetaGroupsCreateToManyRelationshipRequestBuilder(id, buildBetaGroupsLinkagesRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBetaGroupsCreateToManyRelationship", localVarResponse);
        }
        return new ApiResponse<>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
          // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBetaGroupsCreateToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBetaGroupsCreateToManyRelationship");
    }
    // verify the required parameter 'buildBetaGroupsLinkagesRequest' is set
    if (buildBetaGroupsLinkagesRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'buildBetaGroupsLinkagesRequest' when calling buildsBetaGroupsCreateToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/betaGroups"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(buildBetaGroupsLinkagesRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildBetaGroupsLinkagesRequest List of related linkages (required)
   * @throws ApiException if fails to make API call
   */
  public void buildsBetaGroupsDeleteToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest) throws ApiException {
    buildsBetaGroupsDeleteToManyRelationship(id, buildBetaGroupsLinkagesRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildBetaGroupsLinkagesRequest List of related linkages (required)
   * @param headers Optional headers to include in the request
   * @throws ApiException if fails to make API call
   */
  public void buildsBetaGroupsDeleteToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest, Map<String, String> headers) throws ApiException {
    buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(id, buildBetaGroupsLinkagesRequest, headers);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildBetaGroupsLinkagesRequest List of related linkages (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest) throws ApiException {
    return buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(id, buildBetaGroupsLinkagesRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildBetaGroupsLinkagesRequest List of related linkages (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsBetaGroupsDeleteToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBetaGroupsDeleteToManyRelationshipRequestBuilder(id, buildBetaGroupsLinkagesRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBetaGroupsDeleteToManyRelationship", localVarResponse);
        }
        return new ApiResponse<>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
          // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBetaGroupsDeleteToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildBetaGroupsLinkagesRequest buildBetaGroupsLinkagesRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBetaGroupsDeleteToManyRelationship");
    }
    // verify the required parameter 'buildBetaGroupsLinkagesRequest' is set
    if (buildBetaGroupsLinkagesRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'buildBetaGroupsLinkagesRequest' when calling buildsBetaGroupsDeleteToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/betaGroups"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(buildBetaGroupsLinkagesRequest);
      localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @return BuildBetaDetailResponse
   * @throws ApiException if fails to make API call
   */
  public BuildBetaDetailResponse buildsBuildBetaDetailGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include) throws ApiException {
    return buildsBuildBetaDetailGetToOneRelated(id, fieldsBuildBetaDetails, fieldsBuilds, include, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param headers Optional headers to include in the request
   * @return BuildBetaDetailResponse
   * @throws ApiException if fails to make API call
   */
  public BuildBetaDetailResponse buildsBuildBetaDetailGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildBetaDetailResponse> localVarResponse = buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(id, fieldsBuildBetaDetails, fieldsBuilds, include, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @return ApiResponse&lt;BuildBetaDetailResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildBetaDetailResponse> buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include) throws ApiException {
    return buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(id, fieldsBuildBetaDetails, fieldsBuilds, include, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildBetaDetailResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildBetaDetailResponse> buildsBuildBetaDetailGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBuildBetaDetailGetToOneRelatedRequestBuilder(id, fieldsBuildBetaDetails, fieldsBuilds, include, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBuildBetaDetailGetToOneRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildBetaDetailResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildBetaDetailResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildBetaDetailResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildBetaDetailResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBuildBetaDetailGetToOneRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> include, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBuildBetaDetailGetToOneRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/buildBetaDetail"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[buildBetaDetails]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildBetaDetails]", fieldsBuildBetaDetails));
    localVarQueryParameterBaseName = "fields[builds]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[builds]", fieldsBuilds));
    localVarQueryParameterBaseName = "include";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "include", include));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return BuildBuildBetaDetailLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildBuildBetaDetailLinkageResponse buildsBuildBetaDetailGetToOneRelationship(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsBuildBetaDetailGetToOneRelationship(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return BuildBuildBetaDetailLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildBuildBetaDetailLinkageResponse buildsBuildBetaDetailGetToOneRelationship(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildBuildBetaDetailLinkageResponse> localVarResponse = buildsBuildBetaDetailGetToOneRelationshipWithHttpInfo(id, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return ApiResponse&lt;BuildBuildBetaDetailLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildBuildBetaDetailLinkageResponse> buildsBuildBetaDetailGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsBuildBetaDetailGetToOneRelationshipWithHttpInfo(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildBuildBetaDetailLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildBuildBetaDetailLinkageResponse> buildsBuildBetaDetailGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsBuildBetaDetailGetToOneRelationshipRequestBuilder(id, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsBuildBetaDetailGetToOneRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildBuildBetaDetailLinkageResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildBuildBetaDetailLinkageResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildBuildBetaDetailLinkageResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildBuildBetaDetailLinkageResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsBuildBetaDetailGetToOneRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsBuildBetaDetailGetToOneRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/buildBetaDetail"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterDiagnosticType filter by attribute &#39;diagnosticType&#39; (optional)
   * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures (optional)
   * @param limit maximum resources per page (optional)
   * @return DiagnosticSignaturesResponse
   * @throws ApiException if fails to make API call
   */
  public DiagnosticSignaturesResponse buildsDiagnosticSignaturesGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterDiagnosticType, @jakarta.annotation.Nullable List<String> fieldsDiagnosticSignatures, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsDiagnosticSignaturesGetToManyRelated(id, filterDiagnosticType, fieldsDiagnosticSignatures, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterDiagnosticType filter by attribute &#39;diagnosticType&#39; (optional)
   * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures (optional)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return DiagnosticSignaturesResponse
   * @throws ApiException if fails to make API call
   */
  public DiagnosticSignaturesResponse buildsDiagnosticSignaturesGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterDiagnosticType, @jakarta.annotation.Nullable List<String> fieldsDiagnosticSignatures, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<DiagnosticSignaturesResponse> localVarResponse = buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(id, filterDiagnosticType, fieldsDiagnosticSignatures, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterDiagnosticType filter by attribute &#39;diagnosticType&#39; (optional)
   * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures (optional)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;DiagnosticSignaturesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<DiagnosticSignaturesResponse> buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterDiagnosticType, @jakarta.annotation.Nullable List<String> fieldsDiagnosticSignatures, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(id, filterDiagnosticType, fieldsDiagnosticSignatures, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterDiagnosticType filter by attribute &#39;diagnosticType&#39; (optional)
   * @param fieldsDiagnosticSignatures the fields to include for returned resources of type diagnosticSignatures (optional)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;DiagnosticSignaturesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<DiagnosticSignaturesResponse> buildsDiagnosticSignaturesGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterDiagnosticType, @jakarta.annotation.Nullable List<String> fieldsDiagnosticSignatures, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsDiagnosticSignaturesGetToManyRelatedRequestBuilder(id, filterDiagnosticType, fieldsDiagnosticSignatures, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsDiagnosticSignaturesGetToManyRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<DiagnosticSignaturesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        DiagnosticSignaturesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<DiagnosticSignaturesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<DiagnosticSignaturesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsDiagnosticSignaturesGetToManyRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterDiagnosticType, @jakarta.annotation.Nullable List<String> fieldsDiagnosticSignatures, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsDiagnosticSignaturesGetToManyRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/diagnosticSignatures"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "filter[diagnosticType]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[diagnosticType]", filterDiagnosticType));
    localVarQueryParameterBaseName = "fields[diagnosticSignatures]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[diagnosticSignatures]", fieldsDiagnosticSignatures));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return BuildDiagnosticSignaturesLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildDiagnosticSignaturesLinkagesResponse buildsDiagnosticSignaturesGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsDiagnosticSignaturesGetToManyRelationship(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return BuildDiagnosticSignaturesLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildDiagnosticSignaturesLinkagesResponse buildsDiagnosticSignaturesGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildDiagnosticSignaturesLinkagesResponse> localVarResponse = buildsDiagnosticSignaturesGetToManyRelationshipWithHttpInfo(id, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;BuildDiagnosticSignaturesLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildDiagnosticSignaturesLinkagesResponse> buildsDiagnosticSignaturesGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsDiagnosticSignaturesGetToManyRelationshipWithHttpInfo(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildDiagnosticSignaturesLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildDiagnosticSignaturesLinkagesResponse> buildsDiagnosticSignaturesGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsDiagnosticSignaturesGetToManyRelationshipRequestBuilder(id, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsDiagnosticSignaturesGetToManyRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildDiagnosticSignaturesLinkagesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildDiagnosticSignaturesLinkagesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildDiagnosticSignaturesLinkagesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildDiagnosticSignaturesLinkagesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsDiagnosticSignaturesGetToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsDiagnosticSignaturesGetToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/diagnosticSignatures"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param filterVersion filter by attribute &#39;version&#39; (optional)
   * @param filterExpired filter by attribute &#39;expired&#39; (optional)
   * @param filterProcessingState filter by attribute &#39;processingState&#39; (optional)
   * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute &#39;betaAppReviewSubmission.betaReviewState&#39; (optional)
   * @param filterUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param filterPreReleaseVersionVersion filter by attribute &#39;preReleaseVersion.version&#39; (optional)
   * @param filterPreReleaseVersionPlatform filter by attribute &#39;preReleaseVersion.platform&#39; (optional)
   * @param filterBuildAudienceType filter by attribute &#39;buildAudienceType&#39; (optional)
   * @param filterPreReleaseVersion filter by id(s) of related &#39;preReleaseVersion&#39; (optional)
   * @param filterApp filter by id(s) of related &#39;app&#39; (optional)
   * @param filterBetaGroups filter by id(s) of related &#39;betaGroups&#39; (optional)
   * @param filterAppStoreVersion filter by id(s) of related &#39;appStoreVersion&#39; (optional)
   * @param filterId filter by id(s) (optional)
   * @param existsUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param sort comma-separated list of sort expressions; resources will be sorted as specified (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @return BuildsResponse
   * @throws ApiException if fails to make API call
   */
  public BuildsResponse buildsGetCollection(@jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters) throws ApiException {
    return buildsGetCollection(filterVersion, filterExpired, filterProcessingState, filterBetaAppReviewSubmissionBetaReviewState, filterUsesNonExemptEncryption, filterPreReleaseVersionVersion, filterPreReleaseVersionPlatform, filterBuildAudienceType, filterPreReleaseVersion, filterApp, filterBetaGroups, filterAppStoreVersion, filterId, existsUsesNonExemptEncryption, sort, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, limit, include, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, null);
  }

  /**
   * 
   * 
   * @param filterVersion filter by attribute &#39;version&#39; (optional)
   * @param filterExpired filter by attribute &#39;expired&#39; (optional)
   * @param filterProcessingState filter by attribute &#39;processingState&#39; (optional)
   * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute &#39;betaAppReviewSubmission.betaReviewState&#39; (optional)
   * @param filterUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param filterPreReleaseVersionVersion filter by attribute &#39;preReleaseVersion.version&#39; (optional)
   * @param filterPreReleaseVersionPlatform filter by attribute &#39;preReleaseVersion.platform&#39; (optional)
   * @param filterBuildAudienceType filter by attribute &#39;buildAudienceType&#39; (optional)
   * @param filterPreReleaseVersion filter by id(s) of related &#39;preReleaseVersion&#39; (optional)
   * @param filterApp filter by id(s) of related &#39;app&#39; (optional)
   * @param filterBetaGroups filter by id(s) of related &#39;betaGroups&#39; (optional)
   * @param filterAppStoreVersion filter by id(s) of related &#39;appStoreVersion&#39; (optional)
   * @param filterId filter by id(s) (optional)
   * @param existsUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param sort comma-separated list of sort expressions; resources will be sorted as specified (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return BuildsResponse
   * @throws ApiException if fails to make API call
   */
  public BuildsResponse buildsGetCollection(@jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildsResponse> localVarResponse = buildsGetCollectionWithHttpInfo(filterVersion, filterExpired, filterProcessingState, filterBetaAppReviewSubmissionBetaReviewState, filterUsesNonExemptEncryption, filterPreReleaseVersionVersion, filterPreReleaseVersionPlatform, filterBuildAudienceType, filterPreReleaseVersion, filterApp, filterBetaGroups, filterAppStoreVersion, filterId, existsUsesNonExemptEncryption, sort, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, limit, include, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param filterVersion filter by attribute &#39;version&#39; (optional)
   * @param filterExpired filter by attribute &#39;expired&#39; (optional)
   * @param filterProcessingState filter by attribute &#39;processingState&#39; (optional)
   * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute &#39;betaAppReviewSubmission.betaReviewState&#39; (optional)
   * @param filterUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param filterPreReleaseVersionVersion filter by attribute &#39;preReleaseVersion.version&#39; (optional)
   * @param filterPreReleaseVersionPlatform filter by attribute &#39;preReleaseVersion.platform&#39; (optional)
   * @param filterBuildAudienceType filter by attribute &#39;buildAudienceType&#39; (optional)
   * @param filterPreReleaseVersion filter by id(s) of related &#39;preReleaseVersion&#39; (optional)
   * @param filterApp filter by id(s) of related &#39;app&#39; (optional)
   * @param filterBetaGroups filter by id(s) of related &#39;betaGroups&#39; (optional)
   * @param filterAppStoreVersion filter by id(s) of related &#39;appStoreVersion&#39; (optional)
   * @param filterId filter by id(s) (optional)
   * @param existsUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param sort comma-separated list of sort expressions; resources will be sorted as specified (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @return ApiResponse&lt;BuildsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildsResponse> buildsGetCollectionWithHttpInfo(@jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters) throws ApiException {
    return buildsGetCollectionWithHttpInfo(filterVersion, filterExpired, filterProcessingState, filterBetaAppReviewSubmissionBetaReviewState, filterUsesNonExemptEncryption, filterPreReleaseVersionVersion, filterPreReleaseVersionPlatform, filterBuildAudienceType, filterPreReleaseVersion, filterApp, filterBetaGroups, filterAppStoreVersion, filterId, existsUsesNonExemptEncryption, sort, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, limit, include, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, null);
  }

  /**
   * 
   * 
   * @param filterVersion filter by attribute &#39;version&#39; (optional)
   * @param filterExpired filter by attribute &#39;expired&#39; (optional)
   * @param filterProcessingState filter by attribute &#39;processingState&#39; (optional)
   * @param filterBetaAppReviewSubmissionBetaReviewState filter by attribute &#39;betaAppReviewSubmission.betaReviewState&#39; (optional)
   * @param filterUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param filterPreReleaseVersionVersion filter by attribute &#39;preReleaseVersion.version&#39; (optional)
   * @param filterPreReleaseVersionPlatform filter by attribute &#39;preReleaseVersion.platform&#39; (optional)
   * @param filterBuildAudienceType filter by attribute &#39;buildAudienceType&#39; (optional)
   * @param filterPreReleaseVersion filter by id(s) of related &#39;preReleaseVersion&#39; (optional)
   * @param filterApp filter by id(s) of related &#39;app&#39; (optional)
   * @param filterBetaGroups filter by id(s) of related &#39;betaGroups&#39; (optional)
   * @param filterAppStoreVersion filter by id(s) of related &#39;appStoreVersion&#39; (optional)
   * @param filterId filter by id(s) (optional)
   * @param existsUsesNonExemptEncryption filter by attribute &#39;usesNonExemptEncryption&#39; (optional)
   * @param sort comma-separated list of sort expressions; resources will be sorted as specified (optional)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param limit maximum resources per page (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildsResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildsResponse> buildsGetCollectionWithHttpInfo(@jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsGetCollectionRequestBuilder(filterVersion, filterExpired, filterProcessingState, filterBetaAppReviewSubmissionBetaReviewState, filterUsesNonExemptEncryption, filterPreReleaseVersionVersion, filterPreReleaseVersionPlatform, filterBuildAudienceType, filterPreReleaseVersion, filterApp, filterBetaGroups, filterAppStoreVersion, filterId, existsUsesNonExemptEncryption, sort, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, limit, include, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsGetCollection", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildsResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildsResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildsResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildsResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsGetCollectionRequestBuilder(@jakarta.annotation.Nullable List<String> filterVersion, @jakarta.annotation.Nullable List<String> filterExpired, @jakarta.annotation.Nullable List<String> filterProcessingState, @jakarta.annotation.Nullable List<String> filterBetaAppReviewSubmissionBetaReviewState, @jakarta.annotation.Nullable List<String> filterUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionVersion, @jakarta.annotation.Nullable List<String> filterPreReleaseVersionPlatform, @jakarta.annotation.Nullable List<String> filterBuildAudienceType, @jakarta.annotation.Nullable List<String> filterPreReleaseVersion, @jakarta.annotation.Nullable List<String> filterApp, @jakarta.annotation.Nullable List<String> filterBetaGroups, @jakarta.annotation.Nullable List<String> filterAppStoreVersion, @jakarta.annotation.Nullable List<String> filterId, @jakarta.annotation.Nullable Boolean existsUsesNonExemptEncryption, @jakarta.annotation.Nullable List<String> sort, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters, Map<String, String> headers) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "filter[version]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[version]", filterVersion));
    localVarQueryParameterBaseName = "filter[expired]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[expired]", filterExpired));
    localVarQueryParameterBaseName = "filter[processingState]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[processingState]", filterProcessingState));
    localVarQueryParameterBaseName = "filter[betaAppReviewSubmission.betaReviewState]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[betaAppReviewSubmission.betaReviewState]", filterBetaAppReviewSubmissionBetaReviewState));
    localVarQueryParameterBaseName = "filter[usesNonExemptEncryption]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[usesNonExemptEncryption]", filterUsesNonExemptEncryption));
    localVarQueryParameterBaseName = "filter[preReleaseVersion.version]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[preReleaseVersion.version]", filterPreReleaseVersionVersion));
    localVarQueryParameterBaseName = "filter[preReleaseVersion.platform]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[preReleaseVersion.platform]", filterPreReleaseVersionPlatform));
    localVarQueryParameterBaseName = "filter[buildAudienceType]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[buildAudienceType]", filterBuildAudienceType));
    localVarQueryParameterBaseName = "filter[preReleaseVersion]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[preReleaseVersion]", filterPreReleaseVersion));
    localVarQueryParameterBaseName = "filter[app]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[app]", filterApp));
    localVarQueryParameterBaseName = "filter[betaGroups]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[betaGroups]", filterBetaGroups));
    localVarQueryParameterBaseName = "filter[appStoreVersion]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[appStoreVersion]", filterAppStoreVersion));
    localVarQueryParameterBaseName = "filter[id]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[id]", filterId));
    localVarQueryParameterBaseName = "exists[usesNonExemptEncryption]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("exists[usesNonExemptEncryption]", existsUsesNonExemptEncryption));
    localVarQueryParameterBaseName = "sort";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "sort", sort));
    localVarQueryParameterBaseName = "fields[builds]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[builds]", fieldsBuilds));
    localVarQueryParameterBaseName = "fields[preReleaseVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[preReleaseVersions]", fieldsPreReleaseVersions));
    localVarQueryParameterBaseName = "fields[betaTesters]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaTesters]", fieldsBetaTesters));
    localVarQueryParameterBaseName = "fields[betaBuildLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations));
    localVarQueryParameterBaseName = "fields[appEncryptionDeclarations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations));
    localVarQueryParameterBaseName = "fields[betaAppReviewSubmissions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions));
    localVarQueryParameterBaseName = "fields[apps]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[apps]", fieldsApps));
    localVarQueryParameterBaseName = "fields[buildBetaDetails]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildBetaDetails]", fieldsBuildBetaDetails));
    localVarQueryParameterBaseName = "fields[appStoreVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreVersions]", fieldsAppStoreVersions));
    localVarQueryParameterBaseName = "fields[buildIcons]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildIcons]", fieldsBuildIcons));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParameterBaseName = "include";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "include", include));
    localVarQueryParameterBaseName = "limit[betaBuildLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[betaBuildLocalizations]", limitBetaBuildLocalizations));
    localVarQueryParameterBaseName = "limit[betaGroups]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[betaGroups]", limitBetaGroups));
    localVarQueryParameterBaseName = "limit[buildBundles]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[buildBundles]", limitBuildBundles));
    localVarQueryParameterBaseName = "limit[icons]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[icons]", limitIcons));
    localVarQueryParameterBaseName = "limit[individualTesters]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[individualTesters]", limitIndividualTesters));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @return BuildResponse
   * @throws ApiException if fails to make API call
   */
  public BuildResponse buildsGetInstance(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters) throws ApiException {
    return buildsGetInstance(id, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, include, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return BuildResponse
   * @throws ApiException if fails to make API call
   */
  public BuildResponse buildsGetInstance(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildResponse> localVarResponse = buildsGetInstanceWithHttpInfo(id, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, include, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @return ApiResponse&lt;BuildResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildResponse> buildsGetInstanceWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters) throws ApiException {
    return buildsGetInstanceWithHttpInfo(id, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, include, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuilds the fields to include for returned resources of type builds (optional)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param fieldsBetaBuildLocalizations the fields to include for returned resources of type betaBuildLocalizations (optional)
   * @param fieldsAppEncryptionDeclarations the fields to include for returned resources of type appEncryptionDeclarations (optional)
   * @param fieldsBetaAppReviewSubmissions the fields to include for returned resources of type betaAppReviewSubmissions (optional)
   * @param fieldsApps the fields to include for returned resources of type apps (optional)
   * @param fieldsBuildBetaDetails the fields to include for returned resources of type buildBetaDetails (optional)
   * @param fieldsAppStoreVersions the fields to include for returned resources of type appStoreVersions (optional)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param include comma-separated list of relationships to include (optional)
   * @param limitBetaBuildLocalizations maximum number of related betaBuildLocalizations returned (when they are included) (optional)
   * @param limitBetaGroups maximum number of related betaGroups returned (when they are included) (optional)
   * @param limitBuildBundles maximum number of related buildBundles returned (when they are included) (optional)
   * @param limitIcons maximum number of related icons returned (when they are included) (optional)
   * @param limitIndividualTesters maximum number of related individualTesters returned (when they are included) (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildResponse> buildsGetInstanceWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsGetInstanceRequestBuilder(id, fieldsBuilds, fieldsPreReleaseVersions, fieldsBetaTesters, fieldsBetaBuildLocalizations, fieldsAppEncryptionDeclarations, fieldsBetaAppReviewSubmissions, fieldsApps, fieldsBuildBetaDetails, fieldsAppStoreVersions, fieldsBuildIcons, include, limitBetaBuildLocalizations, limitBetaGroups, limitBuildBundles, limitIcons, limitIndividualTesters, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsGetInstance", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsGetInstanceRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuilds, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable List<String> fieldsBetaBuildLocalizations, @jakarta.annotation.Nullable List<String> fieldsAppEncryptionDeclarations, @jakarta.annotation.Nullable List<String> fieldsBetaAppReviewSubmissions, @jakarta.annotation.Nullable List<String> fieldsApps, @jakarta.annotation.Nullable List<String> fieldsBuildBetaDetails, @jakarta.annotation.Nullable List<String> fieldsAppStoreVersions, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable List<String> include, @jakarta.annotation.Nullable Integer limitBetaBuildLocalizations, @jakarta.annotation.Nullable Integer limitBetaGroups, @jakarta.annotation.Nullable Integer limitBuildBundles, @jakarta.annotation.Nullable Integer limitIcons, @jakarta.annotation.Nullable Integer limitIndividualTesters, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsGetInstance");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[builds]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[builds]", fieldsBuilds));
    localVarQueryParameterBaseName = "fields[preReleaseVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[preReleaseVersions]", fieldsPreReleaseVersions));
    localVarQueryParameterBaseName = "fields[betaTesters]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaTesters]", fieldsBetaTesters));
    localVarQueryParameterBaseName = "fields[betaBuildLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaBuildLocalizations]", fieldsBetaBuildLocalizations));
    localVarQueryParameterBaseName = "fields[appEncryptionDeclarations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appEncryptionDeclarations]", fieldsAppEncryptionDeclarations));
    localVarQueryParameterBaseName = "fields[betaAppReviewSubmissions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaAppReviewSubmissions]", fieldsBetaAppReviewSubmissions));
    localVarQueryParameterBaseName = "fields[apps]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[apps]", fieldsApps));
    localVarQueryParameterBaseName = "fields[buildBetaDetails]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildBetaDetails]", fieldsBuildBetaDetails));
    localVarQueryParameterBaseName = "fields[appStoreVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[appStoreVersions]", fieldsAppStoreVersions));
    localVarQueryParameterBaseName = "fields[buildIcons]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildIcons]", fieldsBuildIcons));
    localVarQueryParameterBaseName = "include";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "include", include));
    localVarQueryParameterBaseName = "limit[betaBuildLocalizations]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[betaBuildLocalizations]", limitBetaBuildLocalizations));
    localVarQueryParameterBaseName = "limit[betaGroups]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[betaGroups]", limitBetaGroups));
    localVarQueryParameterBaseName = "limit[buildBundles]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[buildBundles]", limitBuildBundles));
    localVarQueryParameterBaseName = "limit[icons]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[icons]", limitIcons));
    localVarQueryParameterBaseName = "limit[individualTesters]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit[individualTesters]", limitIndividualTesters));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param limit maximum resources per page (optional)
   * @return BuildIconsWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildIconsWithoutIncludesResponse buildsIconsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsIconsGetToManyRelated(id, fieldsBuildIcons, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return BuildIconsWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildIconsWithoutIncludesResponse buildsIconsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildIconsWithoutIncludesResponse> localVarResponse = buildsIconsGetToManyRelatedWithHttpInfo(id, fieldsBuildIcons, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;BuildIconsWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildIconsWithoutIncludesResponse> buildsIconsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsIconsGetToManyRelatedWithHttpInfo(id, fieldsBuildIcons, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBuildIcons the fields to include for returned resources of type buildIcons (optional)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildIconsWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildIconsWithoutIncludesResponse> buildsIconsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsIconsGetToManyRelatedRequestBuilder(id, fieldsBuildIcons, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsIconsGetToManyRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildIconsWithoutIncludesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildIconsWithoutIncludesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildIconsWithoutIncludesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildIconsWithoutIncludesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsIconsGetToManyRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBuildIcons, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsIconsGetToManyRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/icons"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[buildIcons]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[buildIcons]", fieldsBuildIcons));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return BuildIconsLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildIconsLinkagesResponse buildsIconsGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsIconsGetToManyRelationship(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return BuildIconsLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildIconsLinkagesResponse buildsIconsGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildIconsLinkagesResponse> localVarResponse = buildsIconsGetToManyRelationshipWithHttpInfo(id, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;BuildIconsLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildIconsLinkagesResponse> buildsIconsGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsIconsGetToManyRelationshipWithHttpInfo(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildIconsLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildIconsLinkagesResponse> buildsIconsGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsIconsGetToManyRelationshipRequestBuilder(id, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsIconsGetToManyRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildIconsLinkagesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildIconsLinkagesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildIconsLinkagesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildIconsLinkagesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsIconsGetToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsIconsGetToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/icons"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildIndividualTestersLinkagesRequest List of related linkages (required)
   * @throws ApiException if fails to make API call
   */
  public void buildsIndividualTestersCreateToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest) throws ApiException {
    buildsIndividualTestersCreateToManyRelationship(id, buildIndividualTestersLinkagesRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildIndividualTestersLinkagesRequest List of related linkages (required)
   * @param headers Optional headers to include in the request
   * @throws ApiException if fails to make API call
   */
  public void buildsIndividualTestersCreateToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest, Map<String, String> headers) throws ApiException {
    buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(id, buildIndividualTestersLinkagesRequest, headers);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildIndividualTestersLinkagesRequest List of related linkages (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest) throws ApiException {
    return buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(id, buildIndividualTestersLinkagesRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildIndividualTestersLinkagesRequest List of related linkages (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsIndividualTestersCreateToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsIndividualTestersCreateToManyRelationshipRequestBuilder(id, buildIndividualTestersLinkagesRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsIndividualTestersCreateToManyRelationship", localVarResponse);
        }
        return new ApiResponse<>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
          // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsIndividualTestersCreateToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsIndividualTestersCreateToManyRelationship");
    }
    // verify the required parameter 'buildIndividualTestersLinkagesRequest' is set
    if (buildIndividualTestersLinkagesRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'buildIndividualTestersLinkagesRequest' when calling buildsIndividualTestersCreateToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/individualTesters"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(buildIndividualTestersLinkagesRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildIndividualTestersLinkagesRequest List of related linkages (required)
   * @throws ApiException if fails to make API call
   */
  public void buildsIndividualTestersDeleteToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest) throws ApiException {
    buildsIndividualTestersDeleteToManyRelationship(id, buildIndividualTestersLinkagesRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildIndividualTestersLinkagesRequest List of related linkages (required)
   * @param headers Optional headers to include in the request
   * @throws ApiException if fails to make API call
   */
  public void buildsIndividualTestersDeleteToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest, Map<String, String> headers) throws ApiException {
    buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(id, buildIndividualTestersLinkagesRequest, headers);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildIndividualTestersLinkagesRequest List of related linkages (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest) throws ApiException {
    return buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(id, buildIndividualTestersLinkagesRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildIndividualTestersLinkagesRequest List of related linkages (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> buildsIndividualTestersDeleteToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsIndividualTestersDeleteToManyRelationshipRequestBuilder(id, buildIndividualTestersLinkagesRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsIndividualTestersDeleteToManyRelationship", localVarResponse);
        }
        return new ApiResponse<>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
          // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsIndividualTestersDeleteToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildIndividualTestersLinkagesRequest buildIndividualTestersLinkagesRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsIndividualTestersDeleteToManyRelationship");
    }
    // verify the required parameter 'buildIndividualTestersLinkagesRequest' is set
    if (buildIndividualTestersLinkagesRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'buildIndividualTestersLinkagesRequest' when calling buildsIndividualTestersDeleteToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/individualTesters"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(buildIndividualTestersLinkagesRequest);
      localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param limit maximum resources per page (optional)
   * @return BetaTestersWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public BetaTestersWithoutIncludesResponse buildsIndividualTestersGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsIndividualTestersGetToManyRelated(id, fieldsBetaTesters, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return BetaTestersWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public BetaTestersWithoutIncludesResponse buildsIndividualTestersGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<BetaTestersWithoutIncludesResponse> localVarResponse = buildsIndividualTestersGetToManyRelatedWithHttpInfo(id, fieldsBetaTesters, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;BetaTestersWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BetaTestersWithoutIncludesResponse> buildsIndividualTestersGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsIndividualTestersGetToManyRelatedWithHttpInfo(id, fieldsBetaTesters, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsBetaTesters the fields to include for returned resources of type betaTesters (optional)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BetaTestersWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BetaTestersWithoutIncludesResponse> buildsIndividualTestersGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsIndividualTestersGetToManyRelatedRequestBuilder(id, fieldsBetaTesters, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsIndividualTestersGetToManyRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BetaTestersWithoutIncludesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BetaTestersWithoutIncludesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BetaTestersWithoutIncludesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BetaTestersWithoutIncludesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsIndividualTestersGetToManyRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsBetaTesters, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsIndividualTestersGetToManyRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/individualTesters"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[betaTesters]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[betaTesters]", fieldsBetaTesters));
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return BuildIndividualTestersLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildIndividualTestersLinkagesResponse buildsIndividualTestersGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsIndividualTestersGetToManyRelationship(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return BuildIndividualTestersLinkagesResponse
   * @throws ApiException if fails to make API call
   */
  public BuildIndividualTestersLinkagesResponse buildsIndividualTestersGetToManyRelationship(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildIndividualTestersLinkagesResponse> localVarResponse = buildsIndividualTestersGetToManyRelationshipWithHttpInfo(id, limit, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @return ApiResponse&lt;BuildIndividualTestersLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildIndividualTestersLinkagesResponse> buildsIndividualTestersGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit) throws ApiException {
    return buildsIndividualTestersGetToManyRelationshipWithHttpInfo(id, limit, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param limit maximum resources per page (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildIndividualTestersLinkagesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildIndividualTestersLinkagesResponse> buildsIndividualTestersGetToManyRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsIndividualTestersGetToManyRelationshipRequestBuilder(id, limit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsIndividualTestersGetToManyRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildIndividualTestersLinkagesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildIndividualTestersLinkagesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildIndividualTestersLinkagesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildIndividualTestersLinkagesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsIndividualTestersGetToManyRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable Integer limit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsIndividualTestersGetToManyRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/individualTesters"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "limit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterPlatform filter by attribute &#39;platform&#39; (optional)
   * @param filterMetricType filter by attribute &#39;metricType&#39; (optional)
   * @param filterDeviceType filter by attribute &#39;deviceType&#39; (optional)
   * @return XcodeMetrics
   * @throws ApiException if fails to make API call
   */
  public XcodeMetrics buildsPerfPowerMetricsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterPlatform, @jakarta.annotation.Nullable List<String> filterMetricType, @jakarta.annotation.Nullable List<String> filterDeviceType) throws ApiException {
    return buildsPerfPowerMetricsGetToManyRelated(id, filterPlatform, filterMetricType, filterDeviceType, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterPlatform filter by attribute &#39;platform&#39; (optional)
   * @param filterMetricType filter by attribute &#39;metricType&#39; (optional)
   * @param filterDeviceType filter by attribute &#39;deviceType&#39; (optional)
   * @param headers Optional headers to include in the request
   * @return XcodeMetrics
   * @throws ApiException if fails to make API call
   */
  public XcodeMetrics buildsPerfPowerMetricsGetToManyRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterPlatform, @jakarta.annotation.Nullable List<String> filterMetricType, @jakarta.annotation.Nullable List<String> filterDeviceType, Map<String, String> headers) throws ApiException {
    ApiResponse<XcodeMetrics> localVarResponse = buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterMetricType, filterDeviceType, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterPlatform filter by attribute &#39;platform&#39; (optional)
   * @param filterMetricType filter by attribute &#39;metricType&#39; (optional)
   * @param filterDeviceType filter by attribute &#39;deviceType&#39; (optional)
   * @return ApiResponse&lt;XcodeMetrics&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<XcodeMetrics> buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterPlatform, @jakarta.annotation.Nullable List<String> filterMetricType, @jakarta.annotation.Nullable List<String> filterDeviceType) throws ApiException {
    return buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(id, filterPlatform, filterMetricType, filterDeviceType, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param filterPlatform filter by attribute &#39;platform&#39; (optional)
   * @param filterMetricType filter by attribute &#39;metricType&#39; (optional)
   * @param filterDeviceType filter by attribute &#39;deviceType&#39; (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;XcodeMetrics&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<XcodeMetrics> buildsPerfPowerMetricsGetToManyRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterPlatform, @jakarta.annotation.Nullable List<String> filterMetricType, @jakarta.annotation.Nullable List<String> filterDeviceType, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsPerfPowerMetricsGetToManyRelatedRequestBuilder(id, filterPlatform, filterMetricType, filterDeviceType, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsPerfPowerMetricsGetToManyRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<XcodeMetrics>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        XcodeMetrics responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<XcodeMetrics>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<XcodeMetrics>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsPerfPowerMetricsGetToManyRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> filterPlatform, @jakarta.annotation.Nullable List<String> filterMetricType, @jakarta.annotation.Nullable List<String> filterDeviceType, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsPerfPowerMetricsGetToManyRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/perfPowerMetrics"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "filter[platform]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[platform]", filterPlatform));
    localVarQueryParameterBaseName = "filter[metricType]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[metricType]", filterMetricType));
    localVarQueryParameterBaseName = "filter[deviceType]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "filter[deviceType]", filterDeviceType));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json, application/vnd.apple.xcode-metrics+json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @return PrereleaseVersionWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public PrereleaseVersionWithoutIncludesResponse buildsPreReleaseVersionGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions) throws ApiException {
    return buildsPreReleaseVersionGetToOneRelated(id, fieldsPreReleaseVersions, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param headers Optional headers to include in the request
   * @return PrereleaseVersionWithoutIncludesResponse
   * @throws ApiException if fails to make API call
   */
  public PrereleaseVersionWithoutIncludesResponse buildsPreReleaseVersionGetToOneRelated(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, Map<String, String> headers) throws ApiException {
    ApiResponse<PrereleaseVersionWithoutIncludesResponse> localVarResponse = buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(id, fieldsPreReleaseVersions, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @return ApiResponse&lt;PrereleaseVersionWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<PrereleaseVersionWithoutIncludesResponse> buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions) throws ApiException {
    return buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(id, fieldsPreReleaseVersions, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param fieldsPreReleaseVersions the fields to include for returned resources of type preReleaseVersions (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;PrereleaseVersionWithoutIncludesResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<PrereleaseVersionWithoutIncludesResponse> buildsPreReleaseVersionGetToOneRelatedWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsPreReleaseVersionGetToOneRelatedRequestBuilder(id, fieldsPreReleaseVersions, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsPreReleaseVersionGetToOneRelated", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<PrereleaseVersionWithoutIncludesResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        PrereleaseVersionWithoutIncludesResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<PrereleaseVersionWithoutIncludesResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<PrereleaseVersionWithoutIncludesResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsPreReleaseVersionGetToOneRelatedRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nullable List<String> fieldsPreReleaseVersions, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsPreReleaseVersionGetToOneRelated");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/preReleaseVersion"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "fields[preReleaseVersions]";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("csv", "fields[preReleaseVersions]", fieldsPreReleaseVersions));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return BuildPreReleaseVersionLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildPreReleaseVersionLinkageResponse buildsPreReleaseVersionGetToOneRelationship(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsPreReleaseVersionGetToOneRelationship(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return BuildPreReleaseVersionLinkageResponse
   * @throws ApiException if fails to make API call
   */
  public BuildPreReleaseVersionLinkageResponse buildsPreReleaseVersionGetToOneRelationship(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildPreReleaseVersionLinkageResponse> localVarResponse = buildsPreReleaseVersionGetToOneRelationshipWithHttpInfo(id, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @return ApiResponse&lt;BuildPreReleaseVersionLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildPreReleaseVersionLinkageResponse> buildsPreReleaseVersionGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id) throws ApiException {
    return buildsPreReleaseVersionGetToOneRelationshipWithHttpInfo(id, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildPreReleaseVersionLinkageResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildPreReleaseVersionLinkageResponse> buildsPreReleaseVersionGetToOneRelationshipWithHttpInfo(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsPreReleaseVersionGetToOneRelationshipRequestBuilder(id, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsPreReleaseVersionGetToOneRelationship", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildPreReleaseVersionLinkageResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildPreReleaseVersionLinkageResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildPreReleaseVersionLinkageResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildPreReleaseVersionLinkageResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsPreReleaseVersionGetToOneRelationshipRequestBuilder(@jakarta.annotation.Nonnull String id, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsPreReleaseVersionGetToOneRelationship");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}/relationships/preReleaseVersion"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildUpdateRequest Build representation (required)
   * @return BuildResponse
   * @throws ApiException if fails to make API call
   */
  public BuildResponse buildsUpdateInstance(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildUpdateRequest buildUpdateRequest) throws ApiException {
    return buildsUpdateInstance(id, buildUpdateRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildUpdateRequest Build representation (required)
   * @param headers Optional headers to include in the request
   * @return BuildResponse
   * @throws ApiException if fails to make API call
   */
  public BuildResponse buildsUpdateInstance(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildUpdateRequest buildUpdateRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<BuildResponse> localVarResponse = buildsUpdateInstanceWithHttpInfo(id, buildUpdateRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildUpdateRequest Build representation (required)
   * @return ApiResponse&lt;BuildResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildResponse> buildsUpdateInstanceWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildUpdateRequest buildUpdateRequest) throws ApiException {
    return buildsUpdateInstanceWithHttpInfo(id, buildUpdateRequest, null);
  }

  /**
   * 
   * 
   * @param id the id of the requested resource (required)
   * @param buildUpdateRequest Build representation (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;BuildResponse&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<BuildResponse> buildsUpdateInstanceWithHttpInfo(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildUpdateRequest buildUpdateRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = buildsUpdateInstanceRequestBuilder(id, buildUpdateRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("buildsUpdateInstance", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<BuildResponse>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponse.body().readAllBytes());
        BuildResponse responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<BuildResponse>() {});
        
        localVarResponse.body().close();

        return new ApiResponse<BuildResponse>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder buildsUpdateInstanceRequestBuilder(@jakarta.annotation.Nonnull String id, @jakarta.annotation.Nonnull BuildUpdateRequest buildUpdateRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling buildsUpdateInstance");
    }
    // verify the required parameter 'buildUpdateRequest' is set
    if (buildUpdateRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'buildUpdateRequest' when calling buildsUpdateInstance");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/builds/{id}"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(buildUpdateRequest);
      localVarRequestBuilder.method("PATCH", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
